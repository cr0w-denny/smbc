    const url = new URL(request.url);
    
    // Extract query parameters
{{#each queryParams}}
{{#unless (eq name ../discriminator.case)}}
    const {{name}} = {{#if isNumber}}parseInt({{/if}}url.searchParams.get('{{name}}'){{#if defaultValue}} || '{{defaultValue}}'{{/if}}{{#if isNumber}}){{/if}};
{{/unless}}
{{/each}}
    
    // Get dataset from persistent store
    const allItems = getAll{{entityName}}s();
    
    // Apply filters
    let filteredItems = allItems;
    
{{#if hasSearch}}
    // Apply search filter
    if (search && search !== '') {
      filteredItems = filteredItems.filter((item: any) => 
{{#if searchConfig.fields}}
        [{{#each searchConfig.fields}}'{{this}}'{{#unless @last}}, {{/unless}}{{/each}}]
          .some(field => item[field]?.toString().toLowerCase().includes(search.toLowerCase()))
{{else}}
        JSON.stringify(item).toLowerCase().includes(search.toLowerCase())
{{/if}}
      );
    }
{{/if}}

{{#each filters}}
    // Apply {{name}} filter
    if ({{name}} !== null && {{name}} !== '') {
      filteredItems = filteredItems.filter((item: any) => {
{{#if config}}
        {{!-- Boolean choice strategy: map string choices like 'active'/'inactive' to true/false --}}
        {{#if (eq config.strategy "boolean-choice")}}
        const fieldValue = item.{{config.field}};
        return ({{name}} === 'active' && fieldValue) || ({{name}} === 'inactive' && !fieldValue);
        {{else}}
        {{!-- Exact match strategy: direct comparison --}}
        {{#if (eq config.strategy "exact")}}
        if ({{name}} === 'true' || {{name}} === 'false') {
          return item.{{config.field}} === ({{name}} === 'true');
        }
        return item.{{config.field}}?.toString() === {{name}};
        {{else}}
        {{!-- Partial match strategy (default): substring match --}}
        return item.{{config.field}}?.toString().toLowerCase().includes({{name}}.toLowerCase());
        {{/if}}
        {{/if}}
{{else}}
{{#if isBooleanField}}
        if ({{name}} === 'true' || {{name}} === 'false') {
          return item.{{name}} === ({{name}} === 'true');
        }
        return false;
{{else}}
        return item.{{name}}?.toString().toLowerCase().includes({{name}}.toLowerCase());
{{/if}}
{{/if}}
      });
    }
{{/each}}

{{#if hasSorting}}
    // Apply sorting
    if (sortBy && filteredItems.length > 0) {
      filteredItems.sort((a, b) => {
        const aVal = a[sortBy];
        const bVal = b[sortBy];
        
        {{> sortingLogic}}
      });
    }
{{/if}}
    
{{#if hasPagination}}
    // Apply pagination
    const total = filteredItems.length;
    const startIndex = (page - 1) * pageSize;
    const endIndex = Math.min(startIndex + pageSize, total);
    const paginatedItems = filteredItems.slice(startIndex, endIndex);
{{else}}
    const paginatedItems = filteredItems;
    const total = filteredItems.length;
{{/if}}

{{#if discriminator}}
    // Handle discriminated responses
    const discriminatorValue = url.searchParams.get('{{discriminator.case}}');
    let responseSchema = '{{discriminator.default}}';
    
    const schemaMapping: Record<string, string> = {{{json discriminator.when}}};
    if (discriminatorValue && schemaMapping[discriminatorValue]) {
      responseSchema = schemaMapping[discriminatorValue];
    }
    
    // Transform data based on selected schema
    let transformedItems = paginatedItems;
    if (responseSchema !== '{{entityName}}') {
      transformedItems = paginatedItems.map(item => 
        transform{{entityName}}ToSchema(item, responseSchema)
      );
    }
    
    return HttpResponse.json({
      {{entityPlural}}: transformedItems,
      total,
{{#if hasPagination}}
      page,
      pageSize
{{/if}}
    });
{{else}}
    return HttpResponse.json({
      {{entityPlural}}: paginatedItems,
      total,
{{#if hasPagination}}
      page,
      pageSize
{{/if}}
    });
{{/if}}