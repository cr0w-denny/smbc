import StyleDictionary from "style-dictionary";

// Custom transform for simplified naming
StyleDictionary.registerTransform({
  name: "name/simple",
  type: "name",
  transform: (token) => {
    const path = token.path;

    // Brand colors: color.brand.primary.trad-green → TradGreen
    if (path[0] === "color" && path[1] === "brand" && path[2] === "primary") {
      return path[3].split("-").map(word =>
        word.charAt(0).toUpperCase() + word.slice(1)
      ).join("");
    }

    // Secondary colors: color.secondary.honey-beige.100 → HoneyBeige100
    if (path[0] === "color" && path[1] === "secondary") {
      const colorName = path[2].split("-").map(word =>
        word.charAt(0).toUpperCase() + word.slice(1)
      ).join("");
      return path[3] ? `${colorName}${path[3]}` : colorName;
    }

    // Tertiary colors: color.tertiary.soft-gray.100 → SoftGray100
    if (path[0] === "color" && path[1] === "tertiary") {
      const colorName = path[2].split("-").map(word =>
        word.charAt(0).toUpperCase() + word.slice(1)
      ).join("");
      return path[3] ? `${colorName}${path[3]}` : colorName;
    }

    // Chart colors: color.chart.data-1 → Data1
    if (path[0] === "color" && path[1] === "chart") {
      return path[2].split("-").map((word, index) => {
        if (index === 0) return word.charAt(0).toUpperCase() + word.slice(1);
        return word.charAt(0).toUpperCase() + word.slice(1);
      }).join("");
    }

    // Semantic colors: semantic.color.input.icon.light → InputIconLight
    if (path[0] === "semantic" && path[1] === "color") {
      const parts = path.slice(2); // Remove 'semantic.color'
      return parts.map(part =>
        part.charAt(0).toUpperCase() + part.slice(1)
      ).join("");
    }

    // Legacy semantic colors: color.semantic.success.500 → Success500
    if (path[0] === "color" && path[1] === "semantic") {
      const colorName = path[2].charAt(0).toUpperCase() + path[2].slice(1);
      return path[3] ? `${colorName}${path[3]}` : colorName;
    }

    // Gray colors: color.gray.100 → Gray100
    if (path[0] === "color" && path[1] === "gray") {
      return `Gray${path[2]}`;
    }

    // Fall back to default naming for other tokens
    return path.map(part =>
      part.charAt(0).toUpperCase() + part.slice(1).replace(/-/g, "")
    ).join("");
  }
});

// Custom TypeScript format for v5 that flattens nested objects
StyleDictionary.registerFormat({
  name: "typescript/es6-declarations-flat",
  format: ({ dictionary }) => {
    const flatTokens = [];

    // Helper function to flatten nested tokens
    function flattenToken(token, baseName = '') {
      if (typeof token.value === 'string' || typeof token.value === 'number') {
        // Simple token
        flatTokens.push({
          name: baseName || token.name,
          value: token.value
        });
      } else if (typeof token.value === 'object' && token.value !== null) {
        // Complex object - flatten it recursively
        Object.entries(token.value).forEach(([key, subToken]) => {
          const newName = baseName
            ? `${baseName}${key.charAt(0).toUpperCase()}${key.slice(1)}`
            : `${token.name}${key.charAt(0).toUpperCase()}${key.slice(1)}`;

          if (typeof subToken === 'object' && subToken !== null) {
            if (subToken.value !== undefined) {
              // Has a value property - extract it
              flatTokens.push({ name: newName, value: subToken.value });
            } else {
              // Nested object - recurse deeper
              flattenToken({ name: newName, value: subToken }, newName);
            }
          } else {
            // Direct value
            flatTokens.push({ name: newName, value: subToken });
          }
        });
      }
    }

    // Process all tokens
    dictionary.allTokens.forEach(token => {
      flattenToken(token);
    });

    return `// This file is auto-generated by Style Dictionary
// Do not edit directly

${flatTokens
  .map((token) => {
    const value = JSON.stringify(token.value);
    return `export const ${token.name}: string = ${value};`;
  })
  .join("\n")}
`;
  },
});

// Register custom transform group with simplified naming
StyleDictionary.registerTransformGroup({
  name: "js/simple",
  transforms: ["attribute/cti", "name/simple", "color/hex", "size/px"]
});

export default {
  source: ["tokens/**/*.json"],
  platforms: {
    css: {
      transformGroup: "css",
      buildPath: "dist/css/",
      files: [
        {
          destination: "tokens.css",
          format: "css/variables",
          options: {
            outputReferences: true,
          },
        },
      ],
    },
    scss: {
      transformGroup: "scss",
      buildPath: "dist/scss/",
      files: [
        {
          destination: "_tokens.scss",
          format: "scss/variables",
          options: {
            outputReferences: true,
          },
        },
      ],
    },
    js: {
      transformGroup: "js",
      buildPath: "dist/js/",
      files: [
        {
          destination: "tokens.js",
          format: "javascript/es6",
        },
      ],
    },
    ts: {
      transformGroup: "js/simple",
      buildPath: "src/",
      files: [
        {
          destination: "tokens.generated.ts",
          format: "typescript/es6-declarations-flat",
        },
      ],
    },
  },
};
